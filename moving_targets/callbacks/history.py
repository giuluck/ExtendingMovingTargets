from typing import Dict, Tuple, Any, List, Optional

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

from moving_targets.callbacks.logger import Logger


class History(Logger):
    def __init__(self):
        super(History, self).__init__()
        self.history: Any = []

    def on_iteration_end(self, macs, x, y, val_data: Dict[str, Tuple[Any, Any]], iteration: int, **kwargs):
        self.history.append(pd.DataFrame([self.cache.values()], columns=self.cache.keys(), index=[iteration]))
        self.cache = {}

    def on_process_end(self, macs, val_data: Dict[str, Tuple[Any, Any]], **kwargs):
        self.history = pd.concat(self.history)

    def plot(self, columns: Optional[List[str]] = None, num_columns: int = 4, show: bool = True, **kwargs):
        # handle columns and number of rows
        assert isinstance(self.history, pd.DataFrame), 'Process did not end correctly, therefore no dataframe was built'
        columns = self.history.columns if columns is None else columns
        columns = [c for c in columns if c is None or np.issubdtype(self.history[c].dtype, np.number)]
        n_rows = int(np.ceil(len(columns) / num_columns))
        # handle matplotlib arguments
        plt_args = dict(tight_layout=True)
        plt_args.update(kwargs)
        plt.figure(**plt_args)
        # plot each column in a subplot
        ax = None
        for idx, col in enumerate(columns):
            if col is not None:
                ax = plt.subplot(n_rows, num_columns, idx + 1, sharex=ax)
                sns.lineplot(x=self.history.index, y=self.history[col])
                ax.set(title=col, xlabel='', ylabel='')
        # fix integer x_ticks based on autogenerated ones in order to avoid superimposed values
        ticks = np.unique(ax.get_xticks().round().astype(int))
        ax.set_xticks([t for t in ticks if t in range(self.history.index.min(), self.history.index.max() + 1)])
        # show plots
        if show:
            plt.show()

"""History Callback"""
import logging
from typing import List, Optional as Opt

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

from moving_targets.callbacks.logger import Logger
from moving_targets.util.typing import Matrix, Vector, Dataset, Iteration


class History(Logger):
    """Collects the training information and eventually plots it."""

    def __init__(self):
        super(History, self).__init__()
        self.history: List = []

    # noinspection PyMissingOrEmptyDocstring
    def on_iteration_end(self, macs, x: Matrix, y: Vector, val_data: Opt[Dataset], iteration: Iteration, **kwargs):
        self.history.append(pd.DataFrame([self.cache.values()], columns=self.cache.keys(), index=[iteration]))
        self.cache = {}

    # noinspection PyMissingOrEmptyDocstring
    def on_process_end(self, macs, val_data: Opt[Dataset], **kwargs):
        if len(self.history) > 0:
            self.history = pd.concat(self.history)

    def plot(self, columns: Opt[List[str]] = None, num_columns: int = 4, show: bool = True, **kwargs):
        """Plot the training information.

        Args:
            columns: list of strings representing the names of the columns to plot. If None, plots all the columns.
            num_columns: number of columns in the final subplot.
            show: whether or not to call matplotlib.pyplot.show().
            **kwargs: additional plot arguments.
        """
        if not isinstance(self.history, pd.DataFrame):
            logging.warning('Process did not end correctly, therefore no dataframe can be plotted')
            return
        # handle columns and number of rows
        columns = self.history.columns if columns is None else columns
        for i, c in enumerate(columns):
            if c is None or c not in self.history.columns or not np.issubdtype(self.history[c].dtype, np.number):
                columns[i] = None
        n_rows = int(np.ceil(len(columns) / num_columns))
        # handle matplotlib arguments
        plt_args = dict(tight_layout=True)
        plt_args.update(kwargs)
        plt.figure(**plt_args)
        # plot each column in a subplot
        ax = None
        for idx, col in enumerate(columns):
            if col is not None:
                ax = plt.subplot(n_rows, num_columns, idx + 1, sharex=ax)
                sns.lineplot(x=self.history.index, y=self.history[col])
                ax.set(title=col, xlabel='', ylabel='')
        # fix integer x_ticks based on autogenerated ones in order to avoid superimposed values
        ticks = np.unique(ax.get_xticks().round().astype(int))
        ax.set_xticks([t for t in ticks if t in range(self.history.index.min(), self.history.index.max() + 1)])
        # show plots
        if show:
            plt.show()

"""History Callback"""
import logging
from typing import List, Optional

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

from moving_targets.callbacks.logger import Logger
from moving_targets.util.typing import Iteration, Matrix, Vector, Dataset


class History(Logger):
    """Collects the training information and eventually plots it."""

    def __init__(self):
        """"""
        super(History, self).__init__()

        self._history: List = []
        """An internal list which will be used to create the final DataFrame object at the end of the training."""

    def on_iteration_end(self, macs, x: Matrix, y: Vector, val_data: Optional[Dataset], iteration: Iteration,
                         **additional_kwargs):
        # Creates a dataframe from the cached items and appends them to a list indexed by iteration.
        self._history.append(pd.DataFrame([self._cache.values()], columns=self._cache.keys(), index=[iteration]))
        self._cache = {}

    def on_process_end(self, macs, val_data: Optional[Dataset], **additional_kwargs):
        # Creates a single dataframe by concatenating the sub-dataframes from each iteration.
        if len(self._history) > 0:
            self._history = pd.concat(self._history)

    def plot(self, columns: Optional[List[str]] = None, num_columns: int = 4, show: bool = True, **plt_kwargs):
        """Plots the training information which were previously collected in a dataframe.

        :param columns:
            List of strings representing the names of the columns to plot. If None, plots all the columns.

        :param num_columns:
            Number of columns in the final subplot.

        :param show:
            Whether or not to call `matplotlib.pyplot.show()`.

        :param plt_kwargs:
            Additional plot arguments to be passed to `matplotlib.pyplot.figure()`.
        """
        if not isinstance(self._history, pd.DataFrame):
            logging.warning('Process did not end correctly, therefore no dataframe can be plotted')
            return
        # handle columns and number of rows
        columns = self._history.columns if columns is None else columns
        for i, c in enumerate(columns):
            if c is None or c not in self._history.columns or not np.issubdtype(self._history[c].dtype, np.number):
                columns[i] = None
        n_rows = int(np.ceil(len(columns) / num_columns))
        # handle matplotlib arguments
        plt_args = dict(tight_layout=True)
        plt_args.update(plt_kwargs)
        plt.figure(**plt_args)
        # plot each column in a subplot
        ax = None
        for idx, col in enumerate(columns):
            if col is not None:
                ax = plt.subplot(n_rows, num_columns, idx + 1, sharex=ax)
                sns.lineplot(x=self._history.index, y=self._history[col])
                ax.set(title=col, xlabel='', ylabel='')
        # fix integer x_ticks based on autogenerated ones in order to avoid superimposed values
        ticks = np.unique(ax.get_xticks().round().astype(int))
        ax.set_xticks([t for t in ticks if t in range(self._history.index.min(), self._history.index.max() + 1)])
        # show plots
        if show:
            plt.show()
